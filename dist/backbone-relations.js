// Generated by CoffeeScript 1.4.0
(function() {
  var Backbone, getCtor, hasMany, hasManyVia, hasOne, hook, initialize, _, _base;

  _ = (typeof window !== "undefined" && window !== null ? window._ : void 0) || require('underscore');

  Backbone = (typeof window !== "undefined" && window !== null ? window.Backbone : void 0) || require('backbone');

  getCtor = function(val) {
    if (val instanceof Backbone.Model) {
      return val;
    } else {
      return val();
    }
  };

  hook = function(model) {
    var get, name, rel, set, _ref, _ref1, _ref2, _results;
    if (!model.relations) {
      return;
    }
    _ref = [
      model.get, function() {
        return get.apply(model, arguments);
      }
    ], get = _ref[0], model.get = _ref[1];
    _ref1 = [
      model.set, function() {
        return set.apply(model, arguments);
      }
    ], set = _ref1[0], model.set = _ref1[1];
    _ref2 = model.relations;
    _results = [];
    for (name in _ref2) {
      rel = _ref2[name];
      if (rel.hasOne) {
        _results.push(hasOne(model, name, rel));
      } else if (rel.via) {
        _results.push(hasManyVia(model, name, rel));
      } else {
        _results.push(hasMany(model, name, rel));
      }
    }
    return _results;
  };

  hasOne = function(model, name, rel) {
    var changeId, ctor, destroy, mine;
    ctor = getCtor(rel.hasOne);
    mine = rel.myFk;
    model.set[name] = function(next) {
      var prev;
      if (next === (prev = model.get[name])) {
        return model;
      }
      if (prev) {
        model.stopListening(prev, {
          'change:id': changeId,
          destroy: destroy
        });
      }
      model.set(mine, next != null ? next.id : void 0).get[name] = next;
      if (next) {
        model.listenTo(next, {
          'change:id': changeId,
          destroy: destroy
        });
      }
      return model;
    };
    model.listenTo(ctor.cache(), 'add', function(other) {
      if (other.id && other.id == model.get(mine)) {
        return this.set[name](other);
      }
    });
    model.on("change:" + mine, function(__, val) {
      return this.set[name](ctor.cache().get(val));
    });
    changeId = function(__, val) {
      return model.set(mine, val);
    };
    destroy = function() {
      model.set[name](null);
      if (rel.romeo) {
        return model.trigger('destroy', model, model.collection);
      }
    };
    return model.set[name](ctor.cache().get(model.get(mine)));
  };

  hasMany = function(model, name, rel) {
    var ctor, models, theirs;
    ctor = getCtor(rel.hasMany);
    theirs = rel.theirFk;
    models = model.get[name] = new ctor.Collection;
    models.url = function() {
      return "" + (_.result(model, 'url')) + (_.result(rel, 'url') || ("/" + name));
    };
    (models.filters = {})[theirs] = model;
    models.listenTo(ctor.cache(), "add change:" + theirs, function(other) {
      if (model.id && model.id == other.get(theirs)) {
        return this.add(other);
      }
    });
    models.on("change:" + theirs, function(other) {
      return this.remove(other);
    });
    if (model.id) {
      return models.add(ctor.cache().filter(function(other) {
        return model.id == other.get(theirs);
      }));
    }
  };

  hasManyVia = function(model, name, rel) {
    var ctor, mine, models, theirs, via, viaCtor,
      _this = this;
    ctor = getCtor(rel.hasMany);
    viaCtor = getCtor(rel.via);
    mine = rel.myViaFk;
    theirs = rel.theirViaFk;
    models = model.get[name] = new ctor.Collection;
    models.url = function() {
      return "" + (_.result(model, 'url')) + (_.result(rel, 'url') || ("/" + name));
    };
    models.mine = theirs;
    via = models.via = new viaCtor.Collection;
    via.url = function() {
      return "" + (_.result(model, 'url')) + (_.result(viaCtor.Collection.prototype, 'url'));
    };
    (via.filters = {})[mine] = model;
    via.listenTo(viaCtor.cache(), "add change:" + mine, function(other) {
      if (model.id && model.id == other.get(mine)) {
        return this.add(other);
      }
    });
    via.on("change:" + mine, function(other, val) {
      return this.remove(other);
    });
    models.listenTo(via, 'add', function(other) {
      if (other = ctor.cache().get(other.get(theirs))) {
        return this.add(other);
      }
    });
    models.listenTo(via, 'remove', function(other) {
      return this.remove(ctor.cache().get(other.get(theirs)));
    });
    if (model.id) {
      return via.add(viaCtor.cache().filter(function(other) {
        return model.id == other.get(mine);
      }));
    }
  };

  _.extend(Backbone.Model, {
    cache: function() {
      return this._cache || (this._cache = new this.Collection);
    },
    "new": function(attrs) {
      var model;
      model = this.cache().get(this.prototype._generateId(attrs));
      return (model != null ? model.set.apply(model, arguments) : void 0) || (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this, arguments, function(){});
    }
  });

  initialize = Backbone.Model.prototype.initialize;

  _.extend(Backbone.Model.prototype, {
    initialize: function(attrs, options) {
      initialize.apply(this, arguments);
      if ((options != null ? options.cache : void 0) != null) {
        this.cache = options.cache;
      }
      if (this.cache) {
        this.constructor.cache().add(this);
      }
      return hook(this);
    },
    via: function(rel, id) {
      var attrs, viaCtor;
      if (!(id = (id != null ? id.id : void 0) || id)) {
        return;
      }
      viaCtor = getCtor(this.relations[rel].via);
      (attrs = {})[this.relations[rel].myViaFk] = this.id;
      attrs[this.relations[rel].theirViaFk] = id;
      return this.get[rel].via.get(viaCtor.prototype._generateId(attrs));
    }
  });

  (_base = Backbone.Model.prototype)._generateId || (_base._generateId = function(attrs) {
    if (attrs == null) {
      attrs = this.attributes;
    }
    return attrs[this.idAttribute];
  });

}).call(this);
