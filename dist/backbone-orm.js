// Generated by CoffeeScript 1.3.3
(function() {
  var _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = this._ || require('underscore');

  ((typeof module !== "undefined" && module !== null) && module || {}).exports = this.BackboneOrm = function(Backbone) {
    var Model, getModel;
    if (Backbone == null) {
      Backbone = this.Backbone || require('backbone');
    }
    getModel = function(val) {
      if (val instanceof Model) {
        return val;
      } else {
        return val();
      }
    };
    Model = (function(_super) {

      __extends(Model, _super);

      function Model() {
        return Model.__super__.constructor.apply(this, arguments);
      }

      Model["new"] = function(attributes) {
        var model;
        model = this.cache.get(this.prototype._generateId(attributes));
        return (model != null ? model.set.apply(model, arguments) : void 0) || (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args), t = typeof result;
          return t == "object" || t == "function" ? result || child : child;
        })(this, arguments, function(){});
      };

      Model.prototype.initialize = function() {
        Model.__super__.initialize.apply(this, arguments);
        this._previousId = this.id = this._generateId();
        this.constructor.cache.add(this);
        return this._hookRelations();
      };

      Model.prototype._generateId = function(attributes) {
        var index, val, vals, _i, _len, _ref;
        if (attributes == null) {
          attributes = this.attributes || {};
        }
        if (!this.compositeKey) {
          return attributes[this.idAttribute];
        }
        vals = [];
        _ref = this.compositeKey;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          if ((val = attributes[index]) == null) {
            return void 0;
          }
          vals.push(val);
        }
        return vals.join('-');
      };

      Model.prototype._hookRelations = function() {
        var groups, name, rel, rels, _ref, _results;
        if (!this.relations) {
          return;
        }
        this.get = _.bind(this.get, this);
        this.set = _.bind(this.set, this);
        groups = {};
        _ref = this.relations;
        for (name in _ref) {
          rel = _ref[name];
          if (_.isArray(rel)) {
            groups[name] = rel;
          } else if (rel.hasOne) {
            this._hookHasOne(name, rel);
          } else if (rel.via) {
            this._hookHasManyVia(name, rel);
          } else {
            this._hookHasMany(name, rel);
          }
        }
        _results = [];
        for (name in groups) {
          rels = groups[name];
          _results.push(this._hookGroup(name, rels));
        }
        return _results;
      };

      Model.prototype._hookHasOne = function(name, rel) {
        var k, klass, mine, onDestroyModel, onIdChange,
          _this = this;
        klass = (k = rel.hasOne) instanceof Model ? k : k();
        mine = rel.myFk;
        onIdChange = function() {
          return _this.set(mine, _this.get[name].id);
        };
        onDestroyModel = function() {
          if (rel.romeo) {
            return _this.trigger('destroy', _this, _this.collection);
          } else {
            return _this.set(mine, null);
          }
        };
        (this.set[name] = function() {
          var next, prev;
          if (_this.get(mine)) {
            next = klass["new"]({
              id: _this.get(mine)
            });
          }
          prev = _this.get[name];
          if (next === prev) {
            return;
          }
          if (prev) {
            prev.off('change:id', onIdChange);
            prev.off('destroy', onDestroyModel);
          }
          _this.get[name] = next;
          if (next) {
            next.on('change:id', onIdChange);
            return next.on('destroy', onDestroyModel);
          }
        })();
        klass.cache.on('add', this.set[name]);
        return this.on("change:" + mine, this.set[name]);
      };

      Model.prototype._hookHasMany = function(name, rel) {
        var klass, models, theirs,
          _this = this;
        klass = getModel(rel.hasMany);
        theirs = rel.theirFk;
        models = this.get[name] = new klass.Collection;
        klass.cache.on('add', function(model) {
          if (_this.id === model.get(theirs)) {
            return models.add(model);
          }
        });
        return models.add(klass.cache.filter(function(model) {
          return _this.id === model.get(theirs);
        }));
      };

      Model.prototype._hookHasManyVia = function(name, rel) {
        var klass, mine, models, theirs, via, viaKlass,
          _this = this;
        klass = getModel(rel.hasMany);
        viaKlass = getModel(rel.via);
        mine = rel.myViaFk;
        theirs = rel.theirViaFk;
        models = this.get[name] = new klass.Collection;
        via = models.via = new viaKlass.Collection;
        viaKlass.cache.on('add', function(model) {
          if (_this.id === model.get(mine)) {
            return via.add(model);
          }
        });
        via.on('add', function(model) {
          return models.add(klass["new"]({
            id: model.get(theirs)
          }));
        }).on('remove', function(model) {
          return models.remove(models.get(model.get(theirs)));
        });
        klass.cache.on('add', function(model) {
          if (via.find(function(model2) {
            return model2.get(theirs === model.id);
          })) {
            return models.add(model);
          }
        });
        models.on('add', function(model) {
          var attributes;
          attributes = {};
          attributes[mine] = _this.id;
          attributes[theirs] = model.id;
          return via.add(viaKlass["new"](attributes));
        }).on('remove', function(model) {
          return via.remove(via.find(function(model2) {
            return model.id === model2.get(theirs);
          }));
        });
        return via.add(viaKlass.cache.filter(function(model) {
          return _this.id === model.get(mine);
        }));
      };

      Model.prototype._hookGroup = function(name, rels) {
        var group, klass, rel, _i, _len, _results;
        klass = getModel(this.relations[rels[0]].hasMany);
        group = this.get[name] = new klass.Collection;
        _results = [];
        for (_i = 0, _len = rels.length; _i < _len; _i++) {
          rel = rels[_i];
          group.add((rel = this.get[rel]).models);
          _results.push(rel.on('add', function(model) {
            return group.add(model);
          }).on('remove', function(model) {
            return group.remove(model);
          }));
        }
        return _results;
      };

      Model.prototype.via = function(rel, id) {
        var group, via, _i, _len,
          _this = this;
        if (id != null ? id.id : void 0) {
          id = id.id;
        }
        if (group = this.relations[rel].group) {
          for (_i = 0, _len = group.length; _i < _len; _i++) {
            rel = group[_i];
            if (via = this.via(rel, id)) {
              return via;
            }
          }
          return void 0;
        }
        return this.get[rel].via.find(function(model) {
          return id === model.get(_this.relations[rel].theirViaFk);
        });
      };

      Model.prototype.change = function() {
        this._previousId = this.id;
        this.id = this._generateId();
        return Model.__super__.change.apply(this, arguments);
      };

      return Model;

    })(Backbone.Model);
    Model.Collection = (function(_super) {

      __extends(Collection, _super);

      function Collection() {
        return Collection.__super__.constructor.apply(this, arguments);
      }

      Collection.prototype.model = Model;

      Collection.prototype._onModelEvent = function(event, model, collection, options) {
        if (model && event === 'change' && model.id !== model._previousId) {
          delete this._byId[model._previousId];
          if (model.id != null) {
            this._byId[model.id] = model;
          }
        }
        return Collection.__super__._onModelEvent.apply(this, arguments);
      };

      Collection.prototype.fetch = function(options) {
        var success,
          _this = this;
        options = options ? _.clone(options) : {};
        success = options.success;
        options.success = function(resp, status, xhr) {
          var attrs, models, _i, _len, _ref;
          models = [];
          _ref = _this.parse(resp);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attrs = _ref[_i];
            models.push = _this.model["new"](attrs);
          }
          _this[options.add ? 'add' : 'reset'](models);
          if (success) {
            success(_this, resp, options);
          }
          return _this.trigger('sync', _this, resp, options);
        };
        options.error = Backbone.wrapError(options.error, this, options);
        return this.sync('read', this, options);
      };

      Collection.prototype.save = function(options) {
        var success,
          _this = this;
        options = options ? _.clone(options) : {};
        success = options.success;
        options.success = function(resp, status, xhr) {
          var attrs, i, _i, _len, _ref;
          _ref = _this.parse(resp);
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            attrs = _ref[i];
            _this.at(i).set(attrs, xhr);
          }
          if (success) {
            success(_this, resp, options);
          }
          return _this.trigger('sync', _this, resp, options);
        };
        options.error = Backbone.wrapError(options.error, this, options);
        return this.sync('create', this, options);
      };

      Collection.prototype.destroy = function(options) {
        var success;
        options = options ? _.clone(options) : {};
        success = options.success;
        options.success = function(resp) {
          var model, _i, _len, _ref;
          _ref = this.models;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            model = _ref[_i];
            model.trigger('destroy', model, model.collection, options);
            if (success) {
              success(model, resp, options);
            }
          }
          return this.trigger('sync', this, resp, options);
        };
        options.error = Backbone.wrapError(options.error, this, options);
        return this.sync('delete', this, options);
      };

      return Collection;

    })(Backbone.Collection);
    return Model;
  };

  if (typeof Backbone !== "undefined" && Backbone !== null) {
    this.BackboneOrm = this.BackboneOrm();
  }

}).call(this);
